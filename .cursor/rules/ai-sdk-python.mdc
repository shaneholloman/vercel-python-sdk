---
globs: src/*.py
alwaysApply: false
---
# AI SDK Python Codebase Rules

You are working with the AI SDK Python codebase - a pure Python re-implementation of Vercel's popular AI SDK for TypeScript. This codebase provides zero-configuration functions that work consistently across AI providers with first-class streaming, tool-calling, and structured output support.

## Core Architecture Principles

### 1. Provider-Agnostic Design

- All core functions (`generate_text`, `generate_object`, `embed`, etc.) work with any provider
- Providers implement common interfaces defined in `src/ai_sdk/providers/`
- New providers can be added by implementing the base classes

### 2. Strong Pydantic Typing

- **ALWAYS** use Pydantic models for all data structures
- All public functions must have complete type hints
- Return types should be Pydantic models when possible
- Use `Optional[T]` for nullable parameters, never `Union[T, None]`

### 3. Zero-Configuration Philosophy

- Functions should work out-of-the-box with minimal setup
- Sensible defaults for all parameters
- Environment variable configuration for API keys
- No complex configuration files required

## Codebase Structure

```
src/ai_sdk/
├── __init__.py              # Main exports and version
├── types.py                 # Core Pydantic models and type definitions
├── generate_text.py         # Text generation functionality
├── generate_object.py       # Structured output generation
├── embed.py                 # Embedding functionality
├── tool.py                  # Tool calling functionality
└── providers/               # Provider implementations
    ├── __init__.py
    ├── language_model.py    # Base language model interface
    ├── embedding_model.py   # Base embedding model interface
    ├── openai.py           # OpenAI provider
    └── anthropic.py        # Anthropic provider
```

## Key Patterns and Conventions

### 1. Pydantic Model Usage

**ALWAYS** define Pydantic models for:

- Function parameters (when complex)
- Return values
- Configuration objects
- API response structures

```python
from pydantic import BaseModel, Field
from typing import Optional, List

class TextGenerationResult(BaseModel):
    text: str = Field(description="Generated text content")
    usage: Optional[Usage] = Field(default=None, description="Token usage information")
    model: str = Field(description="Model identifier used")

class Usage(BaseModel):
    prompt_tokens: int
    completion_tokens: int
    total_tokens: int
```

### 2. Provider Interface Pattern

All providers must implement base interfaces:

```python
from abc import ABC, abstractmethod
from typing import AsyncIterator, Optional
from pydantic import BaseModel

class LanguageModel(ABC):
    @abstractmethod
    async def generate_text(
        self,
        prompt: str,
        system: Optional[str] = None,
        **kwargs
    ) -> TextGenerationResult:
        pass

    @abstractmethod
    async def stream_text(
        self,
        prompt: str,
        system: Optional[str] = None,
        **kwargs
    ) -> AsyncIterator[str]:
        pass
```

### 3. Function Design Pattern

Core functions follow this pattern:

1. Accept provider model as first parameter
2. Validate inputs with Pydantic
3. Delegate to provider implementation
4. Return structured Pydantic result

```python
def generate_text(
    model: LanguageModel,
    prompt: str,
    system: Optional[str] = None,
    **kwargs
) -> TextGenerationResult:
    """Generate text using the specified language model."""
    # Input validation
    if not prompt.strip():
        raise ValueError("Prompt cannot be empty")

    # Delegate to provider
    return await model.generate_text(prompt=prompt, system=system, **kwargs)
```

## Adding New Features

### 1. Adding a New Provider

1. **Create provider file** in `src/ai_sdk/providers/`
2. **Implement base interfaces** from `language_model.py` or `embedding_model.py`
3. **Add provider factory function** in the provider file
4. **Update `__init__.py`** to export the new provider
5. **Add tests** in `tests/` directory
6. **Add documentation** in `docs/sdk/providers/`

Example provider structure:

```python
# src/ai_sdk/providers/new_provider.py
from .language_model import LanguageModel
from ..types import TextGenerationResult

class NewProviderLanguageModel(LanguageModel):
    def __init__(self, model: str, api_key: Optional[str] = None, **kwargs):
        self.model = model
        self.api_key = api_key or os.getenv("NEW_PROVIDER_API_KEY")
        # Initialize client

    async def generate_text(self, prompt: str, system: Optional[str] = None, **kwargs) -> TextGenerationResult:
        # Implementation here
        pass

def new_provider(model: str, **kwargs) -> NewProviderLanguageModel:
    """Create a new provider language model instance."""
    return NewProviderLanguageModel(model=model, **kwargs)
```

### 2. Adding New Core Functions

1. **Create function** in appropriate module (e.g., `generate_text.py`)
2. **Define Pydantic models** for parameters and return values in `types.py`
3. **Add comprehensive type hints**
4. **Write docstring** with Google-style format
5. **Add tests** with both sync and async versions
6. **Update documentation**

### 3. Adding New Types

1. **Define in `src/ai_sdk/types.py`**
2. **Use Pydantic BaseModel**
3. **Add Field descriptions**
4. **Include validation if needed**
5. **Add to exports in `__init__.py`**

## Testing Patterns

### 1. Test Structure

- Use `pytest` for all tests
- Group related tests in classes
- Use descriptive test names
- Mock external API calls

### 2. Test Examples

```python
import pytest
from unittest.mock import patch
from ai_sdk import generate_text, openai

class TestGenerateText:
    def test_basic_text_generation(self):
        model = openai("gpt-4o-mini")
        result = generate_text(model=model, prompt="Hello")
        assert result.text is not None
        assert isinstance(result.text, str)

    @pytest.mark.asyncio
    async def test_streaming_text(self):
        model = openai("gpt-4o-mini")
        stream = stream_text(model=model, prompt="Hello")
        async for chunk in stream.text_stream:
            assert chunk is not None
```

## Documentation Standards

### 1. Code Documentation

- Use Google-style docstrings
- Include type hints for all parameters
- Provide usage examples
- Document exceptions

### 2. API Documentation

- Document all parameters with types
- Show request/response examples
- Include error handling
- Provide complete working examples

## Error Handling Patterns

### 1. Input Validation

```python
from pydantic import ValidationError

def validate_prompt(prompt: str) -> str:
    if not prompt or not prompt.strip():
        raise ValueError("Prompt cannot be empty")
    return prompt.strip()
```

### 2. Provider Errors

```python
class ProviderError(Exception):
    """Base exception for provider-specific errors."""
    pass

class RateLimitError(ProviderError):
    """Raised when rate limit is exceeded."""
    pass
```

## Configuration Patterns

### 1. Environment Variables

- Use standard naming: `PROVIDER_API_KEY`
- Provide fallbacks to environment variables
- Allow direct parameter passing

### 2. Provider Configuration

```python
class ProviderConfig(BaseModel):
    api_key: Optional[str] = None
    base_url: Optional[str] = None
    timeout: int = 30
    max_retries: int = 3
```

## Performance Considerations

### 1. Async Support

- All I/O operations should be async
- Provide both sync and async versions of functions
- Use `asyncio` for concurrent operations

### 2. Streaming

- Implement streaming for all text generation
- Use async generators for streaming responses
- Handle backpressure appropriately

### 3. Batching

- Implement batching for embeddings
- Use appropriate batch sizes
- Handle rate limits gracefully

## Security Best Practices

### 1. API Key Handling

- Never log API keys
- Use environment variables
- Validate API key format
- Rotate keys regularly

### 2. Input Sanitization

- Validate all user inputs
- Sanitize prompts before sending to APIs
- Handle malicious inputs gracefully

## Common Patterns to Follow

### 1. Provider Factory Functions

```python
def openai(model: str, **kwargs) -> OpenAILanguageModel:
    """Create an OpenAI language model instance."""
    return OpenAILanguageModel(model=model, **kwargs)
```

### 2. Result Objects

```python
class GenerationResult(BaseModel):
    text: str
    usage: Optional[Usage] = None
    model: str
    finish_reason: Optional[str] = None
```

### 3. Streaming Responses

```python
class StreamingResult(BaseModel):
    text_stream: AsyncIterator[str]
    usage: Optional[Usage] = None

    async def text(self) -> str:
        """Collect all streamed text."""
        return "".join([chunk async for chunk in self.text_stream])
```

## When Adding New Features

1. **Check existing patterns** in similar functions
2. **Follow the established naming conventions**
3. **Use Pydantic models for all data structures**
4. **Add comprehensive tests**
5. **Update documentation**
6. **Consider backward compatibility**
7. **Add type hints for all public APIs**
8. **Include error handling**
9. **Follow the zero-configuration principle**
10. **Ensure provider-agnostic design**

## Common Pitfalls to Avoid

1. **Don't hardcode API endpoints** - use configuration
2. **Don't skip input validation** - always validate
3. **Don't forget type hints** - they're required
4. **Don't ignore error handling** - handle all error cases
5. **Don't break provider abstraction** - keep providers interchangeable
6. **Don't forget async support** - provide both sync and async versions
7. **Don't skip documentation** - document all public APIs
8. **Don't ignore testing** - add tests for all new functionality

## Code Quality Standards

1. **Use Ruff for formatting and linting**
2. **Use Ty for type checking**
3. **Follow PEP 8 with 88-character line limit**
4. **Use Google-style docstrings**
5. **Add comprehensive type hints**
6. **Write tests for all new functionality**
7. **Update documentation for all changes**
8. **Use conventional commit messages**
9. **Do not add unnecessarily comments**

Remember: This codebase prioritizes **simplicity**, **type safety**, and **zero-configuration** usage. All new features should maintain these principles while being provider-agnostic and well-tested.
description:
globs:
alwaysApply: false

---
